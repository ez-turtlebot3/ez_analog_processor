"""
ROS2 Node that subscribes to analog pin data and publishes it to AWS IoT Core.

This script creates a ROS2 node that:
1. Subscribes to the '/processed_analog' topic to receive Float32MultiArray messages
    - '/processed_analog' is a topic generated by a ROS2 node from the ez_tb3_streamer package
      (https://github.com/travis-mendoza/ez_tb3_streamer/tree/main)
    - If you prefer to publish '/analog_pins' directly, that implementation is commented out
      in the AnalogPinDataPublisher class
2. Connects to AWS IoT Core using MQTT
3. Publishes received sensor data to AWS IoT Core in JSON format

The published JSON message includes:
- sensor_readings: List of analog pin values
- device_id: The Greengrass thing name
- timestamp: UTC timestamp of the reading
- sensor_type: Type of sensor (default: "Analog")

Dependencies:
- ROS2 (rclpy)
- AWS IoT SDK
- PyYAML

Environment Variables Required:
- AWS_IOT_ENDPOINT: AWS IoT Core endpoint
- DEVICE_CERTIFICATE: Path to device certificate (default: /greengrass/v2/device.pem.crt)
- DEVICE_PRIVATE_KEY: Path to private key (default: /greengrass/v2/private.pem.key)
- AMAZON_ROOT_CERTIFICATE: Path to root CA (default: /greengrass/v2/AmazonRootCA1.pem)
- MQTT_TOPIC: AWS IoT Core topic (default: ez-tb/sensordata/analog)
- SENSOR_TYPE: Type of sensor data (default: Analog)

Usage:
    python3 publish_analog_pin_data_to_AWS.py
"""

import datetime
import json
import logging
import uuid
import os
import sys
from concurrent.futures import Future

import yaml
from awscrt import mqtt
from awsiot import mqtt_connection_builder
import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32MultiArray


def get_device_name():
    with open('/greengrass/v2/config.yaml', 'r') as f:
        config = yaml.safe_load(f)
        thing_name = config['system']['thingName']
    return thing_name


# --- Logging Setup ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


# Environment variables
AWS_IOT_ENDPOINT = os.getenv('AWS_IOT_ENDPOINT')
if not AWS_IOT_ENDPOINT:
    logger.error(
        "AWS_IOT_ENDPOINT environment variable is not set. Please set it in your .env.pi file."
        )
    sys.exit(1)

DEVICE_CERTIFICATE = os.getenv('DEVICE_CERTIFICATE', "/greengrass/v2/device.pem.crt")
DEVICE_PRIVATE_KEY = os.getenv('DEVICE_PRIVATE_KEY', "/greengrass/v2/private.pem.key")
AMAZON_ROOT_CERTIFICATE = os.getenv('AMAZON_ROOT_CERTIFICATE', "/greengrass/v2/AmazonRootCA1.pem")
MQTT_TOPIC = os.getenv('MQTT_TOPIC', "ez-tb/sensordata/analog")
SENSOR_TYPE = os.getenv('SENSOR_TYPE', "Analog")

# Variables that are unlikely to change
MQTT_PORT = 8883  # Port for MQTT over TLS, default: 8883
DEVICE_ID = get_device_name()
MQTT_CLIENT_ID = f"{DEVICE_ID}-{uuid.uuid4()}"  # MQTT unique client Id
PUBLISH_INTERVAL = 1


# --- Global Variables ---
mqtt_connection = None
connection_established = Future()  # Used to signal when connection is complete


class AnalogPinDataPublisher(Node):
    def __init__(self, mqtt_connection):
        super().__init__('analog_pin_data_publisher')
        self.mqtt_connection = mqtt_connection
        self.subscription = self.create_subscription(
            # UInt16MultiArray,
            # '/analog_pins',
            Float32MultiArray,
            '/processed_analog',
            self.sensor_callback,
            10
        )
        self.get_logger().info('Analog pin data publisher node initialized')

    def sensor_callback(self, msg):
        try:
            utc_datetime = datetime.datetime.now()
            message_json = json.dumps({
                "sensor_readings": list(msg.data),
                "device_id": DEVICE_ID,
                "timestamp": utc_datetime.strftime('%Y-%m-%d %H:%M:%S'),
                "sensor_type": SENSOR_TYPE
            })

            logger.info(f"Publishing message to topic '{MQTT_TOPIC}': {message_json}")
            publish_future, packet_id = self.mqtt_connection.publish(
                topic=MQTT_TOPIC,
                payload=message_json,
                qos=mqtt.QoS.AT_LEAST_ONCE
            )

            try:
                publish_future.result(timeout=5.0)
                logger.info(f"Message published successfully with packet ID {packet_id}.")
            except Exception as e:
                logger.warning(f"Publish timed out or failed: {e}")

        except Exception as e:
            logger.error(f"Error processing sensor data: {e}")


# --- Callback Functions (Optional but Recommended) ---

def on_connection_success(connection, callback_data):
    logger.info(f"Connection Successful to endpoint {AWS_IOT_ENDPOINT}")
    connection_established.set_result(True)  # Signal that connection is up


def on_connection_failure(connection, error):
    logger.error(f"Connection Failed with error: {error}")
    connection_established.set_result(False)  # Signal connection failure


def on_connection_interrupted(connection, error):
    logger.warning(f"Connection Interrupted with error: {error}. Reconnecting...")
    # SDK will typically handle reconnection automatically based on retry settings


def on_connection_resumed(connection, return_code, session_present):
    logger.info(
        f"Connection Resumed. Return code: {return_code}, Session present: {session_present}"
        )


# --- Main Program Logic ---

def build_mqtt_connection():
    """Build and return the MQTT connection object."""
    logger.info("Building MQTT connection...")
    try:
        connection = mqtt_connection_builder.mtls_from_path(
            endpoint=AWS_IOT_ENDPOINT,
            port=MQTT_PORT,
            cert_filepath=DEVICE_CERTIFICATE,
            pri_key_filepath=DEVICE_PRIVATE_KEY,
            ca_filepath=AMAZON_ROOT_CERTIFICATE,
            client_id=MQTT_CLIENT_ID,
            clean_session=True,  # Start a clean session on connect
            keep_alive_secs=30,  # Send MQTT PINGREQ every 30 seconds
            # --- Optional: Add callbacks ---
            on_connection_success=on_connection_success,
            on_connection_failure=on_connection_failure,
            on_connection_interrupted=on_connection_interrupted,
            on_connection_resumed=on_connection_resumed,
            # --- Optional: Configure timeouts/retries ---
            # http_proxy_options=None # Add if behind HTTP proxy
            # connect_timeout_ms=5000
        )
        return connection
    except Exception as e:
        logger.error(f"An unexpected error occurred during connection build: {e}")
        return None


def main():
    # Initialize ROS2
    rclpy.init()

    # Build MQTT connection
    mqtt_connection = build_mqtt_connection()
    if not mqtt_connection:
        logger.error("Exiting due to connection build failure.")
        return

    # Connect to AWS IoT Core
    logger.info(f"Connecting to {AWS_IOT_ENDPOINT} with client ID '{MQTT_CLIENT_ID}'...")
    connect_future = mqtt_connection.connect()
    connect_future.result()

    if not connection_established.result():
        logger.error("Could not establish connection. Exiting.")
        return

    logger.info("Connection established. Starting ROS2 node...")

    # Create and run the publisher node
    node = AnalogPinDataPublisher(mqtt_connection)

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        logger.info("Keyboard interrupt detected. Exiting...")
    except Exception as e:
        logger.error(f"An error occurred: {e}")
    finally:
        # Cleanup
        node.destroy_node()
        rclpy.shutdown()

        # Disconnect MQTT
        logger.info("Disconnecting MQTT...")
        disconnect_future = mqtt_connection.disconnect()
        disconnect_future.result()
        logger.info("Disconnected.")


if __name__ == '__main__':
    main()
